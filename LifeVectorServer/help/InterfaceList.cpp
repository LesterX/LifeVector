#include "InterfaceList.h"
using namespace std;

InterfaceList::InterfaceList() {
	readNetworkDirectory(listOfInterfaceNames);
	generateNetworkInterfaces(listOfInterfaceNames, listOfInterfaces);
};
vector<NetworkInterface> InterfaceList::getListOfInterfaces() const{
	return listOfInterfaces;
}

/*Create a check for string startsWith another string*/
bool InterfaceList::startsWith(const string& s, const string& prefix) {
	return s.size() >= prefix.size() && s.compare(0, prefix.size(), prefix) == 0;
}
/*Create a function to read the network directory and generate a vector of strings
 * from the network interface file names*/
int InterfaceList::readNetworkDirectory (vector<string> &fileList)
{
	DIR *dp;
	struct dirent *dirp;
	//Check if file can be opened
	if((dp  = opendir(FILENAME.c_str())) == NULL) {
		cout << "Error(" << errno << ") opening " << FILENAME << endl;
		return errno;
	}
	//check if end of file
	while ((dirp = readdir(dp)) != NULL) {
		if (!startsWith(string(dirp->d_name), ".")){
			fileList.push_back(string(dirp->d_name));
		}
	}
	closedir(dp);
	return 0;
}

/* Generate the interface objects from the interface file names generated by readNetworkDirectory */
void InterfaceList::generateNetworkInterfaces(vector<string> listOfInterfaceNames, vector<NetworkInterface> &listOfInterfaces){
	for(int i = 0; i < listOfInterfaceNames.size() ; i++){
		NetworkInterface tempInterface(listOfInterfaceNames[i]);
		listOfInterfaces.push_back(tempInterface);
	}
}
//Override stdout operator
ostream& operator<<(ostream& os, const InterfaceList& interfaceList){
	vector<NetworkInterface> ifTemp = interfaceList.getListOfInterfaces();
	for (int i = 0; i < ifTemp.size(); i ++){
		os << "\n" + string(60,'=') + "\n";
		os << ifTemp[i];
		os << "\n" + string(60,'=') + "\n";
	}
	return os;
}




